#/bin/sh
#See https://stackoverflow.com/a/59330239
exec awk "$(sed '1,3d' "$0")" "$@"

function help_text() {
return \
"fixedwidth2csv                                                                 \n" \
"                                                                               \n" \
"Given n fixedwidth tables in STDIN, each with a header, turn each table into   \n" \
"its CSV equivalent.                                                            \n" \
"                                                                               \n" \
"For example, given:                                                            \n" \
"                                                                               \n" \
"cat << EOF | fixedwidth2csv -d '|' -c 'country' -c 'district' -c 'city'        \n" \
"country       district city                                                    \n" \
"United States New York New York                                                \n" \
"Canada        Ontario  Toronto                                                 \n" \
"                                                                               \n" \
"country district      city                                                     \n" \
"France  Île-de-France Paris                                                    \n" \
"Spain   Madrid        Madrid                                                   \n" \
"EOF                                                                            \n" \
"                                                                               \n" \
"we get,                                                                        \n" \
"                                                                               \n" \
"country|district|city                                                          \n" \
"United States|New York|New York                                                \n" \
"Canada|Ontario|Toronto                                                         \n" \
"                                                                               \n" \
"country|district|city                                                          \n" \
"France|Île-de-France|Paris                                                     \n" \
"Spain|Madrid|Madrid                                                            \n" \
".                                                                              \n" \
"                                                                               \n" \
"Note that `gawk` provides FIXEDWIDTH, but you need to know the width of the    \n" \
"columns ahead of time [or calculate it on the fly]. This program does that for \n" \
"you.                                                                           \n" \
"                                                                               \n" \
"Options:                                                                       \n" \
"  -d Delimiter string to insert. Default is a comma.                           \n" \
"  -c Column name to match on. You may pass multiple column names to reduce     \n" \
"     risk of false positives.  THE ORDER OF COLUMN NAMES MATTERS. For example, \n" \
"     given the table above, -c country -c district would match, but x          \n" \
"     -c district -c country would not.                                         \n" \
"  -h Print this help text.                                                     \n" \
}

function parse_args(argv, argc, result) {

    DELIMITER = 1
    COLUMN_NAME = 2
    NONE = 3

    column_num = 1
    for (i = 1; i < argc; i++) {
        if (argv[i] == "-h" || argv[i] == "--help") {
            print help_text()
            exit 0
        }
        if (argv[i] == "-d") {
            context = DELIMITER
        } 

        else if (argv[i] == "-c") {
            context = COLUMN_NAME
        }

        else if (context == DELIMITER) {
            result["delimiter"] = argv[i]
            context = NONE
        }
     
       else if (context == COLUMN_NAME) {
           result["columns", column_num++] = argv[i]
           context = NONE
       }
    }
    
    return column_num - 1
}


BEGIN {
    last_columns_idx = parse_args(ARGV, ARGC, args)

    if (ARGC == 1) {
        print help_text()
        exit 0
    }

    if (! args["columns", 1])  {
        print "At least one column name must be specified." 
        exit 1
    }

    column_regex = "[[:space:]]*"

    for (i = 1; i < last_columns_idx; i++) {
        column_regex = column_regex args["columns", i] "[[:space:]]+" 
    }
    column_regex = column_regex args["columns", last_columns_idx] "[[:space:]]*"

    #remove all args to prevent `awk: can't open file -c` 
    for (i = 1; i < ARGC; i++) {
        delete ARGV[i];
    }


    print column_regex
}

{
    if ($0 ~ column_regex) {
        chars_len = split($0, chars, "")
        on_whitespace = 0
        current_field_size = 0
        field_widths_idx = 1

        for (i = 1 ; i <= chars_len; i++) {
            if (chars[i] == " " && on_whitespace == 0) {
                on_whitespace = 1
                current_field_size++
            }

            else if (chars[i] == " " && on_whitespace == 1) {
                current_field_size++
            }

            else if (chars[i] != " " && on_whitespace == 0) {
                current_field_size++
            }
            else if (chars[i] != " " && on_whitespace == 1) {
                field_widths[field_widths_idx++] = current_field_size
                current_field_size = 1
                on_whitespace = 0
            }
        }

        #Sentinel value as we dont care about the length of the last field. Just consume
        #the rest of the line.

        field_widths[field_widths_idx] = -1
    }

    chars_len = split($0, chars, "")
    fields_idx = 1;
    current_field = ""

    for (i = 1; i <= chars_len; i++) {
        current_field = current_field chars[i]
        if (length(current_field) == field_widths[fields_idx]) {
            fields[fields_idx++] = current_field
            current_field = ""
        }
    }
      
    fields[fields_idx] = current_field

    for (i = 1; i <= fields_idx; i++) {
        gsub(/$[[:space:]]+/, "", fields[i])
        gsub(/[[:space:]]+$/, "", fields[i])
    }
      

    for (i = 1; i < fields_idx; i++) {
        printf("%s%s", fields[i], OFS)
    }
        
    print fields[fields_idx]
}
