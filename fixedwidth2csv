#!/bin/sh
set -eu

show_help() {
    cat <<-'OUTER_EOF'
fixedwidth2csv

Given n fixedwidth tables in STDIN, each with a header, turn each table into
its CSV equivalent.

For example, given:

cat << EOF | fixedwidth2csv -d '|' -c 'country' -c 'district' -c 'city'
country       district city
United States New York New York
Canada        Ontario  Toronto

country district      city
France  Île-de-France Paris
Spain   Madrid        Madrid
EOF

we get, 

country|district|city
United States|New York|New York
Canada|Ontario|Toronto
country|district|city
France|Île-de-France|Paris
Spain|Madrid|Madrid
.

Note that `gawk` provides FIXEDWIDTH, but you need to know the width of the columns ahead of time
[or calculate it on the fly]. This program does that for you.

Options:
  -d Delimiter string to insert. Default is a comma.
  -c Column name to match on. You may pass multiple column names to reduce risk of false positives.
     THE ORDER OF COLUMN NAMES MATTERS. For example, given the table above, -c country -c district would
     match, but -c district -c country would not.
  -h Print this help text.
OUTER_EOF
}

if ! command -v gawk > /dev/null; then
    echo "gawk (GNU AWK) must be on the PATH." 1>&2
    exit 1
fi

delimiter=","

if [ "$#" -eq 0 ]; then
    show_help
    exit 0
fi

while getopts 'hc:d:' opt; do
	case "$opt" in
	h)
		show_help
		exit
		;;
	d)
		delimiter="$OPTARG"
		;;
	c)
      set -- "$@" "$OPTARG"
		;;
	esac
done

# We remove any of the "original" args, so we only have an array of our column names in $@.
last=$(($OPTIND - 1))

while [ "$last" -gt 0 ]; do
    shift
    last=$(($last - 1))
done

if [ "$#" -eq 0 ]; then
    echo "No column names passed in." 1>&2
    show_help
    exit 1
fi

gawk -v delimiter="$delimiter" '
    BEGIN {
        OFS = delimiter 

        if (ARGC == 1) {
            print "No column names passed in."
            exit 1
        }

        column_regex = "[[:space:]]*"

        for (i = 1; i < ARGC - 1; i++) {
            column_regex = column_regex ARGV[i] "[[:space:]]+" 
        }
        column_regex = column_regex ARGV[ARGC -1] "[[:space:]]*"

        for (i = 1; i < ARGC; i++) {
            delete ARGV[i];
        }

    }


    {
        if ($0 ~ column_regex) {
            split($0, chars, "")
            on_whitespace = 0
            field_count = 0
            FW = ""

            for (i = 1 ; i <= length(chars); i++) {
                if (chars[i] == " " && on_whitespace == 0) {
                    on_whitespace = 1
                    field_count++
                }

                else if (chars[i] == " " && on_whitespace == 1) {
                    field_count++
                }

                else if (chars[i] != " " && on_whitespace == 0) {
                    field_count++
                }
                else if (chars[i] != " " && on_whitespace == 1) {
                    FW = FW " " field_count
                    field_count = 1
                    on_whitespace = 0
                }
            }

            # For the last field in the header, we may or may not be padded with spaces. We dont care either way.
            # We just use int MAX and call it a day.

            max_field_length = 2 ** 32 - 1
            FIELDWIDTHS = FW " " max_field_length

        }

        $1 = $1
        print $0
    }
    ' "$@"
