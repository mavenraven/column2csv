#!/bin/sh
set -eu

delimiter=","

show_help() {
    cat <<-'OUTER_EOF'
fixedwidth2csv

Given n fixedwidth tables in STDIN, each with a header, turn each table into
its CSV equivalent.

For example, given:

cat << EOF | fixedwidth2csv -d '|' -c 'country' -c 'district' -c 'city'
country       district city
United States New York New York
Canada        Ontario  Toronto

country district      city
France  Île-de-France Paris
Spain   Madrid        Madrid
EOF

we get, 

United States|New York|New York
Canada|Ontario|Toronto
France|Île-de-France|Paris
Spain|Madrid|Madrid
.

Note that `gawk` provides FIXEDWIDTH, but you need to know the width of the columns ahead of time
[or calculate it on the fly]. This program does that for you.

Options:
  -d Delimiter string to insert. Default is a comma.
  -c Column name to match on. You may pass multiple column names to reduce risk of false positives.
     THE ORDER OF COLUMN NAMES MATTERS. For example, given the table above, -c country -c district would
     match, but -c district -c country would not.
OUTER_EOF
}

if [ "$#" -eq 0 ]; then
    show_help
    exit 0
fi

while getopts 'c:d:' opt; do
	case "$opt" in
	h)
		show_help
		exit
		;;
	d)
		delimiter="$OPTARG"
		;;
	c)
      set -- "$@" "$OPTARG"
		;;
	esac
done

# We remove any of the "original" args, so we only have an array of our column names in $@.
last=$(($OPTIND - 1))

while [ "$last" -gt 0 ]; do
    shift
    last=$(($last - 1))
done

if [ "$#" -eq 0 ]; then
    echo "No column names passed in." 1>&2
    show_help
    exit 1
fi

gawk -v delimiter="$delimiter" '
    BEGIN {
        OFS = delimiter 
        print OFS
    }
    ' "$@"





# We require GNU awk because we're using its fixed FIELDWIDTHS functionality.

# The column size changes on every page, so we recalulate it every time we see
# the header.

# We ouput the fields using the ASCII unit seperator as the delimiter. This makes
# it safe to split on later.

#BEGIN { OFS = "\037" }

#$0 ~ "ZIP" && $0 ~ "BLDGNO1" {
#    split($0, chars, "")
#    on_whitespace = 0
#    field_count = 0
#    FIELDWIDTHS = ""
#
#    for (i = 1; i < length($0); i++) {
#        if (chars[i] == " " && on_whitespace == 0) {
#            on_whitespace = 1
#            field_count++
#        }
#        else if (chars[i] == " " && on_whitespace == 1){
#            field_count++
#        }
#        else if (chars[i] != " " && on_whitespace == 0){
#            field_count++
#        }
#        else if (chars[i] != " " && on_whitespace == 1){
#            FIELDWIDTHS = FIELDWIDTHS " " field_count
#            field_count = 1
#            on_whitespace = 0
#        }
#    }
#    next
#}
#
#{ $1 = $1; print $0 }
