#!/bin/sh
set -eu

show_help() {
    cat <<-'OUTER_EOF'
fixedwidth2csv

Given n fixedwidth tables in STDIN, each with a header, turn each table into
its CSV equivalent.

For example, given:

cat << EOF | fixedwidth2csv -d '|' -c 'country' -c 'district' -c 'city'
country       district city
United States New York New York
Canada        Ontario  Toronto

country district      city
France  Île-de-France Paris
Spain   Madrid        Madrid
EOF

we get, 

country|district|city
United States|New York|New York
Canada|Ontario|Toronto
country|district|city
France|Île-de-France|Paris
Spain|Madrid|Madrid
.

Note that `gawk` provides FIXEDWIDTH, but you need to know the width of the columns ahead of time
[or calculate it on the fly]. This program does that for you.

Options:
  -d Delimiter string to insert. Default is a comma.
  -c Column name to match on. You may pass multiple column names to reduce risk of false positives.
     THE ORDER OF COLUMN NAMES MATTERS. For example, given the table above, -c country -c district would
     match, but -c district -c country would not.
  -h Print this help text.
OUTER_EOF
}

if ! command -v gawk > /dev/null; then
    echo "gawk (GNU AWK) must be on the PATH." 1>&2
    exit 1
fi

delimiter=","

if [ "$#" -eq 0 ]; then
    show_help
    exit 0
fi

while getopts 'hc:d:' opt; do
	case "$opt" in
	h)
		show_help
		exit
		;;
	d)
		delimiter="$OPTARG"
		;;
	c)
      set -- "$@" "$OPTARG"
		;;
	esac
done

# We remove any of the "original" args, so we only have an array of our column names in $@.
last=$(($OPTIND - 1))

while [ "$last" -gt 0 ]; do
    shift
    last=$(($last - 1))
done

if [ "$#" -eq 0 ]; then
    echo "No column names passed in." 1>&2
    show_help
    exit 1
fi

gawk -v delimiter="$delimiter" '
    BEGIN {
        OFS = delimiter 

        if (ARGC == 1) {
            print "No column names passed in."
            exit 1
        }

        column_regex = "[[:space:]]*"

        for (i = 1; i < ARGC - 1; i++) {
            column_regex = column_regex ARGV[i] "[[:space:]]+" 
        }
        column_regex = column_regex ARGV[ARGC -1] "[[:space:]]*"

        for (i = 1; i < ARGC; i++) {
            delete ARGV[i];
        }

    }


    {
        if ($0 ~ column_regex) {
            chars_len = split($0, chars, "")
            on_whitespace = 0
            current_field_size = 0
            for (i in field_widths) {
                delete field_widths[i]
            }
            field_widths_idx = 1
            FW = ""

            for (i = 1 ; i <= chars_len; i++) {
                if (chars[i] == " " && on_whitespace == 0) {
                    on_whitespace = 1
                    current_field_size++
                }

                else if (chars[i] == " " && on_whitespace == 1) {
                    current_field_size++
                }

                else if (chars[i] != " " && on_whitespace == 0) {
                    current_field_size++
                }
                else if (chars[i] != " " && on_whitespace == 1) {
                    FW = FW " " current_field_size
                    field_widths[field_widths_idx++] = current_field_size
                    current_field_size = 1
                    on_whitespace = 0
                }
            }

            # For the last field in the header, we may or may not be padded with spaces. We dont care either way.
            # We just use int MAX and call it a day.

            max_field_length = 2^32 - 1
            field_widths[field_widths_idx] = max_field_length
            FIELDWIDTHS = FW " " max_field_length

            next
        }

        chars_len = split($0, chars, "")
        field_num = 1;
        current_field = ""


        for (i = 1; i <= chars_len; i++) {
            current_field = current_field chars[i]
            if (length(current_field) == field_widths[field_num]) {
                $field_num = current_field
                current_field = ""
                field_num++
            }
        }
        $1 = $1
        for (i = 1; i <= NF; i++) {
            gsub(/$[[:space:]]+/, "", $i)
            gsub(/[[:space:]]+$/, "", $i)
        }
        print $0
    }
    ' "$@"
