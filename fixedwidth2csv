#!/bin/sh
set -eu

show_help() {
    cat <<-'OUTER_EOF'
fixedwidth2csv

Given n fixedwidth tables in STDIN, each with a header, turn each table into
its CSV equivalent.

For example, given:

cat << EOF | fixedwidth2csv -d '|' -c 'country' -c 'district' -c 'city'
country       district city
United States New York New York
Canada        Ontario  Toronto

country district      city
France  Île-de-France Paris
Spain   Madrid        Madrid
EOF

we get, 

country|district|city
United States|New York|New York
Canada|Ontario|Toronto
country|district|city
France|Île-de-France|Paris
Spain|Madrid|Madrid
.

Note that `gawk` provides FIXEDWIDTH, but you need to know the width of the columns ahead of time
[or calculate it on the fly]. This program does that for you [and doesn't require gawk, only POSIX awk].

Options:
  -d Delimiter string to insert. Default is a comma.
  -c Column name to match on. You may pass multiple column names to reduce risk of false positives.
     THE ORDER OF COLUMN NAMES MATTERS. For example, given the table above, -c country -c district would
     match, but -c district -c country would not.
  -h Print this help text.
OUTER_EOF
}

delimiter=","

if [ "$#" -eq 0 ]; then
    show_help
    exit 0
fi

while getopts 'hc:d:' opt; do
	case "$opt" in
	h)
		show_help
		exit
		;;
	d)
		delimiter="$OPTARG"
		;;
	c)
      set -- "$@" "$OPTARG"
		;;
	esac
done

# We remove any of the "original" args, so we only have an array of our column names in $@.
last=$(($OPTIND - 1))

while [ "$last" -gt 0 ]; do
    shift
    last=$(($last - 1))
done

if [ "$#" -eq 0 ]; then
    echo "No column names passed in." 1>&2
    show_help
    exit 1
fi

awk -v delimiter="$delimiter" '
    BEGIN {
        OFS = delimiter 

        if (ARGC == 1) {
            print "No column names passed in."
            exit 1
        }

        column_regex = "[[:space:]]*"

        for (i = 1; i < ARGC - 1; i++) {
            column_regex = column_regex ARGV[i] "[[:space:]]+" 
        }
        column_regex = column_regex ARGV[ARGC -1] "[[:space:]]*"

        for (i = 1; i < ARGC; i++) {
            delete ARGV[i];
        }

    }


    {
        if ($0 ~ column_regex) {
            chars_len = split($0, chars, "")
            on_whitespace = 0
            current_field_size = 0
            field_widths_idx = 1

            for (i = 1 ; i <= chars_len; i++) {
                if (chars[i] == " " && on_whitespace == 0) {
                    on_whitespace = 1
                    current_field_size++
                }

                else if (chars[i] == " " && on_whitespace == 1) {
                    current_field_size++
                }

                else if (chars[i] != " " && on_whitespace == 0) {
                    current_field_size++
                }
                else if (chars[i] != " " && on_whitespace == 1) {
                    field_widths[field_widths_idx++] = current_field_size
                    current_field_size = 1
                    on_whitespace = 0
                }
            }

            #Sentinel value as we dont care about the length of the last field. Just consume
            #the rest of the line.

            field_widths[field_widths_idx] = -1
        }

        chars_len = split($0, chars, "")
        fields_idx = 1;
        current_field = ""

        for (i = 1; i <= chars_len; i++) {
            current_field = current_field chars[i]
            if (length(current_field) == field_widths[fields_idx]) {
                fields[fields_idx++] = current_field
                current_field = ""
            }
        }
      
        fields[fields_idx] = current_field

        for (i = 1; i <= fields_idx; i++) {
            gsub(/$[[:space:]]+/, "", fields[i])
            gsub(/[[:space:]]+$/, "", fields[i])
        }
      

        for (i = 1; i < fields_idx; i++) {
            printf("%s%s", fields[i], OFS)
        }
        
        print fields[fields_idx]

    }
    ' "$@"
